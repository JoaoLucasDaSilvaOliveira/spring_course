Annotations e seus significados:

@GetMapping -> mapeia a url necessária para chegar na função em específica
Obs.: Caso não tenha nada nos params, retorna no root da pagina
Ex.: url pai: sistemasunificados.com.br
* @GetMapping("/api/produtos"); -> retorna no path: sistemasunificados.com.br/api/produtos
* @GetMapping(""); -> retorna no path: sistemasunificados.com.br

@RestController -> Combina as annotations @Controller e @ResponseBody
- @Controller: Marca uma classe como um controlador no Spring MVC, ou seja, uma classe que lida com requisições HTTP recebidas. Ele é responsável por processar as requisições e devolver uma resposta.
-@ResponseBody: Serializa a resposta diretamente no corpo da resposta.

@RequestMapping: Podemos entender como se fosse o pai do @Get/Post/Put/Patch/DeleteMapping. Ele aceita qualquer tipo de requisição e podemos definir espefícias.
Ex.:
* @RequestMapping("/produtos")
* @RequestMapping (value = "/produtos", method = RequestMethod.POST)

@RequestBody -> colocamos quando queremos receber o valor de traduzi-lo algo em nossa applicação.
Ex.: Aplicação recebe dados via JSON de algum lugar e precisa traduzir isso em um objeto:
* (Contexto de POST) @RequestBody Produto produto: signigica que vou receber via qualquer coisa (JSON, XML...) os dados e esses dados devem ser traduzidos em uma instância do classe Produto.

@Entity -> declara a classe como uma entidade do banco de dados. O nome dos atributos e o tipo devem ser os mesmos das colunas da tabela
    - @Column -> colocamos acima dos atributos da entidade. Obs.: usa-se caso o nome do atributo seja diferente do nome do banco.
    * @Column (name = "id") private Long identificador. Observe que é diferente os nomes;
    - @Table -> serve como o column, para quando o nome da tabela é diferente do nome da entidade.
    - @Id -> sinaliza que o campo é o identificador (PK), da entidade

@RequiredArgsConstructor -> annotation da dependência lombok. Faz com que todos os atributos final tenham um construtor, sem você precisar declará-los.

@PathVariable -> usamos quando queremos receber um parametro via URL.
Ex.:
* getNome(@PathVariable String nome);
    - Nesse caso faz-se necessário o uso do @GetMapping específico para isso:
    - @GetMapping (/{nome})
    Ex. completo:
    @GetMapping(/{nome})
public void getNome (@PathVariable("nome") String nome). Observe que caso o que for explicitado no mapping seja igual ao que se espera no método, o uso dos ("") é opcional!

@RequestParam -> usamos quando queremos um query param na nossa url.
Ex.:
* GET localhost:8080/produtos?nome=algumNome
    - No código: public Produto getNome (@RequestParam String nome){...}

@Component: classe que age como um compontente no Spring container
    - @Service: classe que contem a regra de negócio / lógica da aplicação.
    - @Controller
    - @Repository

@Scope: define escopos dos Beans da aplicação.
    *INDEPENDENTE O TIPO DO PROJETO
        - @Scope ("singleton"): escopo padrão da aplicação. Usa uma instância para todas as requisições, cria apenas uma vez o objeto e usa durante toda a vida da execução; //MELHOR EM APIS QUE SÃO APENAS RETORNOS E CONSULTAS NO BD
        - @Scope ("prototype"): cria instâncias a cada request e a cada usuário, contrário do singleton.
    * PARA PROJETOS WEB
        - @Scope ("request"): cria uma instância dos objetos a cada request, não salva estado. // MELHOR EM PROJETOS QUE PRECISEM DE INFORMAÇÕES DESCARTÁVEIS DE USUARIO
        - @Scope ("session"): cria as instâncias de acordo com a sessão do usuário, salva temporariamente o estado da aplicação. // MELHOR EM PROJETOS QUE PRECISEM DE INFORMAÇÕES DURÁVEIS DE USUARIO
        - @Scope ("Application"): cria uma instância/variavel que serve para todos os aplicações web
    *Enums úteis
        - @Scope (BeanDefinition.SCOPE_PROTOTYPE)
        - @Scope (BeanDefinition.SCOPE_SINGLETON)
        - @Scope (WebApplicationContext.SCOPE_APPLICATION)
        - @Scope (WebApplicationContext.SCOPE_REQUEST)
        - @Scope (WebApplicationContext.SCOPE_SESSION)

@Value: permite utilizar as properties setadas no arquivo de application.properties/.yml. A sintaxe é a mesma que a de leitura de arquivos .env
Ex.: Usando em propriedades
* @Value (${spring.application.name})
  private String appName;
Ex.: usando em metodos
* public void printAppName (@Value(${spring.aaplication.name}) String appName){
    System.out.println(appName);
}
-Podemos configurar classes também usando as propriedades do sistema, observe:


//////////////////////////////////////////////////////////////////////

Configurações do Spring: arquivo application.properties ou application.yml (só muda a sintaxe):

spring.application.name: nome da aplicação. Ex.: Produtos API

spring.datasource.url: url do banco de dados. Ex.: jdbc:h2:mem:produtos
spring.datasource.username: nome do user do banco. Ex.: joao
spring.datasource.password: senha cadastrada para certo user. Ex.: 1304
spring.jpa.database-platform: dialeto/driver do banco. Ex.: org.hibernate.dialect.H2Dialect
//ESPECÍFICO DO H2
spring.h2.console.enabled: habilita o console web do h2. Ex.: true/false
spring.h2.console.path: caminho web para o console web. Ex.: /h2-bd

////////////////////////////////////////////////////////////////////////////////
Arquitetura do Spring:

-Injeção de dependências:
* Bean: trata-se de um formato de classe. Ela deve conter um construtor default (vazio), getters e setters para todos os atributos, pois dessa forma colocamos a responsabilidade de instanciar a classe para o framework.
* @Configuration: Trata-se de uma annotation que permite que a classe configure a injeção de dependências, utilizase com o
@Bean:
    * @Bean: classe de fato que será injetada pelo spring. É uma pré-configuração de injeção de dependência.
* @Qualifier: usamos quando há vários beans candidatos a serem injetados. Assim dizemos qual queremos injetar.
    Ex.: @Bean ("carroAspirado") public ...(...){...}; @Bean ("carroTurbo") public ...(...){...}; -> Qualifier (name="carroAspirado");
* @Primary: usamos junto com o @Bean para dizer que aquele será a injeção padrão
* Annotations personalizadas com @Qualifiers específicos: Podemos criar annotations com qualifiers injetados.

//////////////////////////////////////////////////////////////////////////////////
Informações Interessantes:
- Quando for o tratamento de erro de uma requisição Http: ResponseStatus(HttpStatus.TIPODOERRO, e.getMessage());
- Lazy Beans (@Lazy): trata-se de uma forma de gerenciar os beans de forma atrasada. Por padrão o lazy, enquanto build de todo o projeto é false, entretanto podemos definir lazy em escopo de classe ou de projeto inteiro.
    - Em escopo de classe @Lazy
    - Em escopo de projeto -> application.properties -> spring.main.lazy-initialization=true/false
               ou          -> (classe instanciada) SpringApplicationBuilder sab.lazyInitialization(true/false)